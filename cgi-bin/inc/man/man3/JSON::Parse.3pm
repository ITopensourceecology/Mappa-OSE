.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "JSON::Parse 3"
.TH JSON::Parse 3 "2012-04-14" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::Parse \- Convert JSON into a Perl variable
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use JSON::Parse \*(Aqjson_to_perl\*(Aq;
\&    my $json = \*(Aq["golden", "fleece"]\*(Aq;
\&    my $perl = json_to_perl ($json);
\&    # Same effect as $perl = [\*(Aqgolden\*(Aq, \*(Aqfleece\*(Aq];
.Ve
.PP
Convert \s-1JSON\s0 into Perl.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
JSON::Parse converts \s-1JSON\s0 into equivalent Perl. The function
\&\*(L"json_to_perl\*(R" takes one argument, a string containing \s-1JSON\s0, and
returns a Perl reference. The input to \f(CW\*(C`json_to_perl\*(C'\fR must be a
complete \s-1JSON\s0 structure.
.PP
The module differs from the standard \s-1JSON\s0 module by simplifying the
handling of Unicode. If its input is marked as Unicode characters, the
strings in its output are also marked as Unicode characters.
.PP
JSON::Parse also provides a high speed validation function,
\&\*(L"valid_json\*(R".
.PP
JSON::Parse is based on C and users require a C compiler to install it.
.PP
\&\s-1JSON\s0 means \*(L"JavaScript Object Notation\*(R" and it is specified in \*(L"\s-1RFC\s0
4627\*(R".
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "json_to_perl"
.IX Subsection "json_to_perl"
.Vb 2
\&    use JSON::Parse \*(Aqjson_to_perl\*(Aq;
\&    my $perl = json_to_perl (\*(Aq{"x":1, "y":2}\*(Aq);
.Ve
.PP
This function converts \s-1JSON\s0 into a Perl structure, either an array
reference or a hash reference.
.PP
If the first argument does not contain a valid \s-1JSON\s0 text,
\&\f(CW\*(C`json_to_perl\*(C'\fR throws a fatal error. See \*(L"\s-1DIAGNOSTICS\s0\*(R" for the
possible error messages.
.PP
If the argument contains valid \s-1JSON\s0, the return value is either a hash
or an array reference. If the input \s-1JSON\s0 text is a serialized object,
a hash reference is returned:
.PP
.Vb 3
\&    my $perl = json_to_perl (\*(Aq{"a":1, "b":2}\*(Aq);
\&    print ref $perl, "\en";
\&    # Prints "HASH".
.Ve
.PP
If the input \s-1JSON\s0 text is a serialized array, an array reference is
returned:
.PP
.Vb 3
\&    my $perl = json_to_perl (\*(Aq["a", "b", "c"]\*(Aq);
\&    print ref $perl, "\en";
\&    # Prints "ARRAY".
.Ve
.SS "valid_json"
.IX Subsection "valid_json"
.Vb 4
\&    use JSON::Parse \*(Aqvalid_json\*(Aq;
\&    if (valid_json ($json)) {
\&        # do something
\&    }
.Ve
.PP
\&\f(CW\*(C`Valid_json\*(C'\fR returns \fI1\fR if its argument is valid \s-1JSON\s0 and \fI0\fR if not.
.PP
Because \f(CW\*(C`valid_json\*(C'\fR does not create any Perl data structures, it
runs about two or three times faster than \*(L"json_to_perl\*(R".
.SH "Mapping from JSON to Perl"
.IX Header "Mapping from JSON to Perl"
\&\s-1JSON\s0 elements are mapped to Perl as follows:
.SS "\s-1JSON\s0 numbers"
.IX Subsection "JSON numbers"
\&\s-1JSON\s0 numbers become Perl strings, rather than numbers. No conversion
from the character string to a numerical value is done. For example
.PP
.Vb 1
\&    my $q = @{json_to_perl (\*(Aq[0.12345]\*(Aq)}[0];
.Ve
.PP
has the same result as a Perl declaration of the form
.PP
.Vb 1
\&    my $q = \*(Aq0.12345\*(Aq;
.Ve
.PP
The conversion is not done because Perl will do the conversion into a
numerical value automatically when the scalar is used in a numerical
context:
.PP
.Vb 2
\&    print \*(Aq0.12345\*(Aq * 5;
\&    # prints 0.61725
.Ve
.PP
See also \*(L"Numbers not checked\*(R".
.SS "\s-1JSON\s0 strings"
.IX Subsection "JSON strings"
\&\s-1JSON\s0 strings become Perl strings. The \s-1JSON\s0 escape characters such as
\&\et for the tab character (see section 2.5 of \*(L"\s-1RFC\s0 4627\*(R") are mapped
to the equivalent \s-1ASCII\s0 character. Unicode escape characters of the
form \euXXXX (see page three of \*(L"\s-1RFC\s0 4627\*(R") are mapped to \s-1UTF\-8\s0
octets. This is done regardless of what input encoding might be used
in the \s-1JSON\s0 text.
.PP
\fIHandling of Unicode\fR
.IX Subsection "Handling of Unicode"
.PP
If the input to \*(L"json_to_perl\*(R" is marked as Unicode characters, the
output strings will be marked as Unicode characters. If the input is
not marked as Unicode characters, the output strings will not be
marked as Unicode characters. Thus,
.PP
.Vb 6
\&    # The scalar $sasori looks like Unicode to Perl
\&    use utf8;
\&    my $sasori = \*(Aq["X"]\*(Aq;
\&    my $p = json_to_perl ($sasori);
\&    print utf8::is_utf8 ($p\->[0]);
\&    # Prints 1.
.Ve
.PP
but
.PP
.Vb 6
\&    # The scalar $ebi does not look like Unicode to Perl
\&    no utf8;
\&    my $ebi = \*(Aq["XX"]\*(Aq;
\&    my $p = json_to_perl ($ebi);
\&    print utf8::is_utf8 ($p\->[0]);
\&    # Prints nothing.
.Ve
.SS "\s-1JSON\s0 arrays"
.IX Subsection "JSON arrays"
\&\s-1JSON\s0 arrays become Perl array references. The elements of the Perl
array are in the same order as they appear in the \s-1JSON\s0.
.PP
Thus
.PP
.Vb 1
\&    my $p = json_to_perl (\*(Aq["monday", "tuesday", "wednesday"]\*(Aq);
.Ve
.PP
has the same result as a Perl declaration of the form
.PP
.Vb 1
\&    my $p = [ \*(Aqmonday\*(Aq, \*(Aqtuesday\*(Aq, \*(Aqwednesday\*(Aq ];
.Ve
.SS "\s-1JSON\s0 objects"
.IX Subsection "JSON objects"
\&\s-1JSON\s0 objects become Perl hashes. The members of the object are mapped
to pairs of key and value in the Perl hash. The string part of each
object member becomes the key of the Perl hash. The value part of each
member is mapped to the value of the Perl hash.
.PP
Thus
.PP
.Vb 5
\&    my $j = <<EOF;
\&    {"monday":["blue", "black"],
\&     "tuesday":["grey", "heart attack"],
\&     "friday":"Gotta get down on Friday"}
\&    EOF
\&
\&    my $p = json_to_perl ($j);
.Ve
.PP
has the same result as a Perl declaration of the form
.PP
.Vb 5
\&    my $p = {
\&        monday => [\*(Aqblue\*(Aq, \*(Aqblack\*(Aq],
\&        tuesday => [\*(Aqgrey\*(Aq, \*(Aqheart attack\*(Aq],
\&        friday => \*(AqGotta get down on Friday\*(Aq,
\&    };
.Ve
.SS "null"
.IX Subsection "null"
The \s-1JSON\s0 null literal is mapped to the undefined value.
See \*(L"False = null = undefined value\*(R".
.SS "true"
.IX Subsection "true"
The \s-1JSON\s0 true literal is mapped to a Perl string with the value 'true'.
.SS "false"
.IX Subsection "false"
The \s-1JSON\s0 false literal is mapped to the undefined value.
See \*(L"False = null = undefined value\*(R".
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
This module imposes the following restrictions on its input.
.IP "\s-1JSON\s0 only" 4
.IX Item "JSON only"
JSON::Parse is a strict parser. It only parses \s-1JSON\s0 which exactly
meets the criteria of \*(L"\s-1RFC\s0 4627\*(R". That means, for example, unlike
the standard \s-1JSON\s0 module, JSON::Parse does not accept single quotes
(') instead of double quotes ("), or numbers with leading zeros, like
0123.
.IP "No incremental parsing" 4
.IX Item "No incremental parsing"
JSON::Parse does not do incremental parsing. JSON::Parse only parses
fully-formed \s-1JSON\s0 strings which include opening and closing brackets.
.IP "\s-1UTF\-8\s0 only" 4
.IX Item "UTF-8 only"
Although \s-1JSON\s0 may come in various encodings of Unicode, JSON::Parse
only parses the \s-1UTF\-8\s0 format. If input is in a different Unicode
encoding than \s-1UTF\-8\s0, convert the input before handing it to this
module. For example, for the \s-1UTF\-16\s0 format,
.Sp
.Vb 3
\&    use Encode \*(Aqdecode\*(Aq;
\&    my $input_utf8 = decode (\*(AqUTF\-16\*(Aq, $input);
\&    my $perl = json_to_perl ($input_utf8);
.Ve
.Sp
or, for a file,
.Sp
.Vb 1
\&    open my $input, "<:encoding(UTF\-16)", \*(Aqsome\-json\-file\*(Aq;
.Ve
.Sp
This module does not attempt to do the determination of the nature of
the octet stream, as described in part 3 of \*(L"\s-1RFC\s0 4627\*(R".
.SH "BUGS"
.IX Header "BUGS"
This is a preliminary version. The following deficiencies are
known. These may be resolved in a later version.
.IP "False = null = undefined value" 4
.IX Item "False = null = undefined value"
At the moment, both of \*(L"false\*(R" and \*(L"null\*(R" in \s-1JSON\s0 are mapped to the
undefined value. \*(L"true\*(R" is mapped to the string \*(L"true\*(R".
.IP "Numbers not checked" 4
.IX Item "Numbers not checked"
The author of this module does not know whether all possible \s-1JSON\s0
floating point numbers are understood by Perl (see \*(L"\s-1JSON\s0 numbers\*(R"
above). Most integer and floating point numbers encountered should be
\&\s-1OK\s0, but there is a chance that there are some numbers allowed in the
\&\s-1JSON\s0 format which Perl cannot understand.
.IP "Line numbers are off by one" 4
.IX Item "Line numbers are off by one"
The line numbers in the error messages are off by one (line 1 is line
0).
.IP "Compilation failure on Windows compilers" 4
.IX Item "Compilation failure on Windows compilers"
The C code which JSON::Parse is based on uses some dialect features of
the \s-1GNU\s0 version of C, and it will not compile on some Microsoft
Windows compilers.
.IP "C compiler required" 4
.IX Item "C compiler required"
At the moment there is no \*(L"pure Perl\*(R" version of the module, so use of
the module requires a C compiler.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
\&\*(L"Valid_json\*(R" does not produce error messages. \*(L"Json_to_perl\*(R" may
produce the following:
.IP "\(bu" 4
unknown failure
.IP "\(bu" 4
a callback routine failed
.IP "\(bu" 4
out of memory
.IP "\(bu" 4
parser failed (this \s-1JSON\s0 is not grammatically correct)
.IP "\(bu" 4
lexer failed (there are stray characters in the input)
.IP "\(bu" 4
unimplemented feature of \s-1JSON\s0 encountered in input
.IP "\(bu" 4
Unicode \euXXXX decoding failed
.IP "\(bu" 4
input was empty
.IP "\(bu" 4
the text did not start with { or [ as it should have
.IP "\(bu" 4
met an unknown escape sequence (backslash \e + character)
.PP
Error messages have the line number and the byte number of the input
which caused the problem.
.PP
(The above error messages are in the file \fIjson_parse.c\fR in the top
level of the distribution. The \*(L"callback routine failed\*(R" and \*(L"out of
memory\*(R" errors are unlikely to occur in normal usage.)
.PP
Parsing errors are fatal, so to continue after an error occurs, put
the parsing into an \f(CW\*(C`eval\*(C'\fR block:
.PP
.Vb 7
\&    my $p;                       
\&    eval {                       
\&        $p = json_to_perl ($j);  
\&    };                           
\&    if ($@) {                    
\&        # handle error           
\&    }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\s-1RFC\s0 4627" 4
.IX Item "RFC 4627"
\&\s-1JSON\s0 is specified in \s-1RFC\s0 (Request For Comments, a kind of internet
standards document) 4627. See, for example,
<http://www.ietf.org/rfc/rfc4627.txt>.
.SH "EXPORTS"
.IX Header "EXPORTS"
The module exports nothing by default. Functions \*(L"json_to_perl\*(R" and
\&\*(L"valid_json\*(R" can be exported on request.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ben Bullock, <bkb@cpan.org>
.SH "LICENSE"
.IX Header "LICENSE"
JSON::Parse can be used, copied, modified and redistributed under the
same terms as Perl itself.
